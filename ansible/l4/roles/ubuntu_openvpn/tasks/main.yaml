---
## OPENVPN SETUP

# L4 — workload-level validation (service-specific secrets/config)
- name: fail if required variables are missing
  fail:
    msg: "missing required variable: {{ item }}"
  when: (lookup('vars', item, default='') | length) == 0
  loop:
    - vpn_config
    - vpn_user
    - vpn_pass

# L4 — workload-specific configuration (provider/profile-specific OpenVPN config)
- name: write expressvpn config file with correct creds path
  copy:
    content: "{{ vpn_config | regex_replace('^auth-user-pass.*', 'auth-user-pass ' ~ vpn_creds_path, multiline=True) }}"
    dest: "{{ vpn_config_path }}"
    owner: root
    group: root
    mode: '0644'

# L4 — workload secrets (credentials are not an OS concern)
- name: write credentials file
  copy:
    content: |
      {{ vpn_user }}
      {{ vpn_pass }}
    dest: "{{ vpn_creds_path }}"
    owner: root
    group: root
    mode: '0600'

# L4 — workload activation (starting/enabling a specific client instance)
- name: enable and start openvpn client service
  systemd:
    name: "openvpn-client@expressvpn.service"
    enabled: true
    state: started

# L4 — operational policy for the workload (service lifecycle behavior)
- name: restart vpn service nightly at midnight
  ansible.builtin.cron:
    name: "restart vpn service"
    user: root
    minute: "0"
    hour: "0"
    job: "systemctl restart openvpn-client@expressvpn.service"

## KILL SWITCH

# L4 — workload introspection (reading service-specific config)
- name: read openvpn conf
  ansible.builtin.slurp:
    src: "{{ openvpn_conf }}"
  register: ovpn_raw

# L4 — workload data preparation (parsing config content)
- name: decode openvpn conf
  ansible.builtin.set_fact:
    ovpn_text: "{{ ovpn_raw.content | b64decode }}"

# L4 — workload override knobs (service-specific behavior)
- name: apply optional overrides
  ansible.builtin.set_fact:
    parsed_remote_host: "{{ override_remote_host | default('', true) }}"
    parsed_remote_port: "{{ override_vpn_port | default('', true) }}"
  when: override_remote_host is defined or override_vpn_port is defined

# L4 — workload config parsing (deriving runtime connection targets)
- name: extract remote pairs (first match wins)
  ansible.builtin.set_fact:
    remote_pairs: "{{ ovpn_text | regex_findall('(?m)^\\s*remote\\s+(\\S+)\\s+(\\d+)') }}"
  when: (parsed_remote_host | default('') | length) == 0 or (parsed_remote_port | default('') | length) == 0

# L4 — workload decision logic (selecting effective remote endpoint)
- name: select parsed remote host/port (from config)
  ansible.builtin.set_fact:
    parsed_remote_host: "{{ (remote_pairs | first | default(['','']))[0] if (parsed_remote_host | default('') | length) == 0 else parsed_remote_host }}"
    parsed_remote_port: "{{ (remote_pairs | first | default(['','']))[1] if (parsed_remote_port | default('') | length) == 0 else parsed_remote_port }}"
  when: (parsed_remote_host | default('') | length) == 0 or (parsed_remote_port | default('') | length) == 0

# L4 — workload diagnostics (debugging service config issues)
- name: show candidate remote lines when parsing fails
  ansible.builtin.debug:
    msg: "{{ ovpn_text.splitlines() | select('match', '^\\s*remote\\b') | list }}"
  when: parsed_remote_host | default('') | length == 0 or parsed_remote_port | default('') | length == 0

# L4 — workload validation (cannot safely apply kill switch without endpoint)
- name: fail if we cannot parse a remote host/port
  ansible.builtin.fail:
    msg: "could not parse remote host/port from {{ openvpn_conf }}"
  when: parsed_remote_host | default('') | length == 0 or parsed_remote_port | default('') | length == 0

# L4 — workload-specific port selection logic
- name: decide vpn port
  ansible.builtin.set_fact:
    effective_vpn_port: "{{ (vpn_port | length > 0) | ternary(vpn_port, parsed_remote_port) }}"

# L4 — workload runtime dependency (resolving provider infrastructure)
- name: resolve vpn server ipv4 addresses
  ansible.builtin.command: getent ahostsv4 {{ parsed_remote_host }}
  register: getent_out
  changed_when: false

# L4 — workload data shaping (inputs for kill switch rules)
- name: build vpn_server_ips list
  ansible.builtin.set_fact:
    vpn_server_ips: "{{ (getent_out.stdout_lines | map('regex_replace', '^(\\S+).*', '\\1') | list) | unique }}"

# L4 — workload safety check (kill switch requires concrete IPs)
- name: fail if no vpn server ips resolved
  ansible.builtin.fail:
    msg: "no vpn server IPs resolved for {{ parsed_remote_host }}"
  when: vpn_server_ips | length == 0

# L4 — workload enforcement (VPN-specific firewall policy)
- name: render nftables rules
  ansible.builtin.template:
    src: nftables.conf.j2
    dest: /etc/nftables.conf
    mode: '0644'

# L4 — workload activation / reconciliation
- name: restart services
  ansible.builtin.systemd:
    name: "{{ item }}"
    state: restarted
    enabled: true
  loop:
    - "nftables"
    - "{{ openvpn_unit }}"
